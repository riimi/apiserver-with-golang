// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mq/academy/ent/useraccount"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
)

// UserAccountCreate is the builder for creating a UserAccount entity.
type UserAccountCreate struct {
	config
	name      *string
	passwd    *string
	email     *string
	createdAt *time.Time
	owner     map[int]struct{}
}

// SetName sets the name field.
func (uac *UserAccountCreate) SetName(s string) *UserAccountCreate {
	uac.name = &s
	return uac
}

// SetPasswd sets the passwd field.
func (uac *UserAccountCreate) SetPasswd(s string) *UserAccountCreate {
	uac.passwd = &s
	return uac
}

// SetEmail sets the email field.
func (uac *UserAccountCreate) SetEmail(s string) *UserAccountCreate {
	uac.email = &s
	return uac
}

// SetCreatedAt sets the createdAt field.
func (uac *UserAccountCreate) SetCreatedAt(t time.Time) *UserAccountCreate {
	uac.createdAt = &t
	return uac
}

// SetOwnerID sets the owner edge to User by id.
func (uac *UserAccountCreate) SetOwnerID(id int) *UserAccountCreate {
	if uac.owner == nil {
		uac.owner = make(map[int]struct{})
	}
	uac.owner[id] = struct{}{}
	return uac
}

// SetOwner sets the owner edge to User.
func (uac *UserAccountCreate) SetOwner(u *User) *UserAccountCreate {
	return uac.SetOwnerID(u.ID)
}

// Save creates the UserAccount in the database.
func (uac *UserAccountCreate) Save(ctx context.Context) (*UserAccount, error) {
	if uac.name == nil {
		return nil, errors.New("ent: missing required field \"name\"")
	}
	if uac.passwd == nil {
		return nil, errors.New("ent: missing required field \"passwd\"")
	}
	if uac.email == nil {
		return nil, errors.New("ent: missing required field \"email\"")
	}
	if uac.createdAt == nil {
		return nil, errors.New("ent: missing required field \"createdAt\"")
	}
	if len(uac.owner) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"owner\"")
	}
	if uac.owner == nil {
		return nil, errors.New("ent: missing required edge \"owner\"")
	}
	return uac.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (uac *UserAccountCreate) SaveX(ctx context.Context) *UserAccount {
	v, err := uac.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (uac *UserAccountCreate) sqlSave(ctx context.Context) (*UserAccount, error) {
	var (
		res sql.Result
		ua  = &UserAccount{config: uac.config}
	)
	tx, err := uac.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	builder := sql.Dialect(uac.driver.Dialect()).
		Insert(useraccount.Table).
		Default()
	if value := uac.name; value != nil {
		builder.Set(useraccount.FieldName, *value)
		ua.Name = *value
	}
	if value := uac.passwd; value != nil {
		builder.Set(useraccount.FieldPasswd, *value)
		ua.Passwd = *value
	}
	if value := uac.email; value != nil {
		builder.Set(useraccount.FieldEmail, *value)
		ua.Email = *value
	}
	if value := uac.createdAt; value != nil {
		builder.Set(useraccount.FieldCreatedAt, *value)
		ua.CreatedAt = *value
	}
	query, args := builder.Query()
	if err := tx.Exec(ctx, query, args, &res); err != nil {
		return nil, rollback(tx, err)
	}
	id, err := res.LastInsertId()
	if err != nil {
		return nil, rollback(tx, err)
	}
	ua.ID = int(id)
	if len(uac.owner) > 0 {
		eid := keys(uac.owner)[0]
		query, args := sql.Update(useraccount.OwnerTable).
			Set(useraccount.OwnerColumn, eid).
			Where(sql.EQ(useraccount.FieldID, id).And().IsNull(useraccount.OwnerColumn)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(uac.owner) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"owner\" %v already connected to a different \"UserAccount\"", keys(uac.owner))})
		}
	}
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	return ua, nil
}
